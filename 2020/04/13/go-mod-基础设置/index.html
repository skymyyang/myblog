<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Golang, mod," />










<meta name="description" content="Go modules 是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。 什么是Go ModulesGo modules 是 Go 语言的依赖解决方案，发布于 Go1.11">
<meta property="og:type" content="article">
<meta property="og:title" content="go mod 基础设置">
<meta property="og:url" content="https://ihere.io/2020/04/13/go-mod-%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/index.html">
<meta property="og:site_name" content="ihere.io">
<meta property="og:description" content="Go modules 是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。 什么是Go ModulesGo modules 是 Go 语言的依赖解决方案，发布于 Go1.11">
<meta property="og:image" content="https://ihere.io/images/golang-no1.png">
<meta property="og:image" content="https://ihere.io/images/golang-no2.png">
<meta property="og:image" content="https://ihere.io/images/golang-no3.png">
<meta property="og:image" content="https://ihere.io/images/golang-no4.png">
<meta property="og:image" content="https://ihere.io/images/golang-no5.png">
<meta property="article:published_time" content="2020-04-13T02:22:38.000Z">
<meta property="article:modified_time" content="2020-04-23T06:35:34.654Z">
<meta property="article:author" content="ihere">
<meta property="article:tag" content="Golang, mod">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ihere.io/images/golang-no1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ihere.io/2020/04/13/go-mod-基础设置/"/>





  <title>go mod 基础设置 | ihere.io</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ihere.io</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ihere.io/2020/04/13/go-mod-%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ihere">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ihere.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">go mod 基础设置</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T10:22:38+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Go modules 是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。</p>
<h2 id="什么是Go-Modules"><a href="#什么是Go-Modules" class="headerlink" title="什么是Go Modules"></a>什么是Go Modules</h2><p>Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。</p>
<p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：</p>
<ol>
<li>Go 语言长久以来的依赖管理问题。</li>
<li>“淘汰”现有的 GOPATH 的使用模式。</li>
<li>统一社区中的其它的依赖管理工具（提供迁移功能）</li>
</ol>
<h2 id="GOPATH-是什么"><a href="#GOPATH-是什么" class="headerlink" title="GOPATH 是什么"></a>GOPATH 是什么</h2><p>GOPATH 是什么，我们可以输入如下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\yang-&gt; go env</span><br><span class="line">set GO111MODULE=</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">set GOBIN=</span><br><span class="line">set GOCACHE=C:\Users\yang-\AppData\Local\go-build</span><br><span class="line">set GOENV=C:\Users\yang-\AppData\Roaming\go\env</span><br><span class="line">set GOEXE=.exe</span><br><span class="line">set GOFLAGS=</span><br><span class="line">set GOHOSTARCH=amd64</span><br><span class="line">set GOHOSTOS=windows</span><br><span class="line">set GONOPROXY=</span><br><span class="line">set GONOSUMDB=</span><br><span class="line">set GOOS=windows</span><br><span class="line">set GOPATH=C:\Users\yang-\go</span><br><span class="line">set GOPRIVATE=</span><br><span class="line">set GOPROXY=https://proxy.golang.org,direct</span><br><span class="line">set GOROOT=c:\go</span><br></pre></td></tr></table></figure>

<p>接着我们进入到GOPATH目录下进行查看，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">go</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br><span class="line">    ├── github.com</span><br><span class="line">    ├── golang.org</span><br><span class="line">    ├── google.golang.org</span><br><span class="line">    ├── gopkg.in</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>GOPATH目录下一共包含了三个子目录，分别是：</p>
<ul>
<li>bin：存储所编译生成的二进制文件。</li>
<li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li>
<li>src：存储所有<code>.go</code>文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以<code>$GOPATH/src/github.com/foo/bar</code>的路径进行存放。</li>
</ul>
<p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下，并且如果执行<code>go get</code>来拉取外部依赖会自动下载并安装到<code>$GOPATH</code>目录下。</p>
<h3 id="弃用GOPATH"><a href="#弃用GOPATH" class="headerlink" title="弃用GOPATH"></a>弃用GOPATH</h3><p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code> 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式，看起来好像没有什么问题，那么为什么我们要弃用呢，参见如下原因：</p>
<ul>
<li>GOPATH 模式下没有版本控制的概念，具有致命的缺陷，至少会造成以下问题：</li>
<li><ul>
<li>在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</li>
<li>在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</li>
<li>你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</li>
</ul>
</li>
<li>Go 语言官方从 Go1.11 起开始推进 Go modules（前身vgo），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用GOPATH模式。</li>
</ul>
<h3 id="govendor"><a href="#govendor" class="headerlink" title="govendor"></a>govendor</h3><p>govendor类似于npm的包管理工具</p>
<p>安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.con/kardianos/govendor</span><br></pre></td></tr></table></figure>

<p>将项目依赖的外部包拷贝到目录下的vendor目录，并通过vendor.json文件记录依赖包的版本。</p>
<h2 id="Go-Modules的产生"><a href="#Go-Modules的产生" class="headerlink" title="Go Modules的产生"></a>Go Modules的产生</h2><p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：GitHub Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？</p>
<p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。</p>
<p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules 的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。</p>
<p>因此与其说是 “在 GOPATH 模式下的产物”，不如说是历史为当前提供了重要的教训，因此出现了 Go modules。</p>
<h3 id="Go-Modules的使用"><a href="#Go-Modules的使用" class="headerlink" title="Go Modules的使用"></a>Go Modules的使用</h3><p>原则上go modules所创建的项目以及目录不需要放在GOPATH之中。</p>
<p>在go modules中我们能使用如下命令进行操作：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td align="left">go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td align="left">go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td align="left">go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td align="left">go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td align="left">go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td align="left">go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td align="left">go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody></table>
<p>在 Go modules 中有如下常用环境变量，我们可以通过 <code>go env</code> 命令来进行查看，如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\yang-&gt; go env</span><br><span class="line">set GO111MODULE=</span><br><span class="line">set GOPROXY=https://proxy.golang.org,direct</span><br><span class="line">set GONOSUMDB=</span><br><span class="line">set GOSUMDB=sum.golang.org</span><br><span class="line">set GONOPROXY=</span><br><span class="line">set GOSUMDB=sum.golang.org</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p>Go语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置</li>
</ul>
<h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h4><p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。</p>
<p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code>，这有一个很严重的问题，就是<code>proxy.golang.org</code> 在国内是无法访问的，因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时，同时设置国内的 Go 模块代理，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go env -w GO111MODULE=on</span></span><br></pre></td></tr></table></figure>

<p>GOPROXY 的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p>
<h5 id="direct是什么"><a href="#direct是什么" class="headerlink" title="direct是什么"></a>direct是什么</h5><p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？</p>
<p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision…” 的错误。</p>
<h4 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a>GOSUMDB</h4><p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。</p>
<p>GOSUMDB 的默认值为：<code>sum.golang.org</code>，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。</p>
<p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 <code>goproxy.cn</code> 就能支持代理 <code>sum.golang.org</code>，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。</p>
<p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：</p>
<ul>
<li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li>
<li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li>
</ul>
<p>也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。</p>
<h4 id="GONOPROXY-GONOSUMDB-GOPRIVATE"><a href="#GONOPROXY-GONOSUMDB-GOPRIVATE" class="headerlink" title="GONOPROXY/GONOSUMDB/GOPRIVATE"></a>GONOPROXY/GONOSUMDB/GOPRIVATE</h4><p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。</p>
<p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。</p>
<p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。</p>
<p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GOPRIVATE=<span class="string">"git.example.com,github.com/eddycjy/mquote"</span></span></span><br></pre></td></tr></table></figure>

<p>设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。</p>
<p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPRIVATE="*.example.com"</span><br></pre></td></tr></table></figure>

<p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，<strong>需要注意的是不包括 example.com 本身</strong>。</p>
<h3 id="开启-Go-Modules"><a href="#开启-Go-Modules" class="headerlink" title="开启 Go Modules"></a>开启 Go Modules</h3><p>目前 Go modules 并不是默认开启，因此Go语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在Go1.11至 Go1.14 中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置。</li>
</ul>
<p>如果你不确定你当前的值是什么，可以执行<code>go env</code>命令，查看结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env</span></span><br><span class="line">GO111MODULE="off"</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果需要对 GO111MODULE 的值进行变更，推荐通过<code>go env</code>命令进行设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go env -w GO111MODULE&#x3D;on</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是如果对应的系统环境变量有值了（进行过设置），<code>go env</code>是不支持覆盖写入的，否则会出现如下报错信息：<code>warning: go env -w GO111MODULE=... does not override conflicting OS environment variable</code>。</p>
<p>又或是可以通过直接设置系统环境变量（写入对应的 .bash_profile 文件亦可）来实现这个目的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> GO111MODULE=on</span></span><br></pre></td></tr></table></figure>

<h3 id="使用go-modules初始化项目"><a href="#使用go-modules初始化项目" class="headerlink" title="使用go modules初始化项目"></a>使用go modules初始化项目</h3><p>在完成 Go modules 的开启后，我们需要创建一个示例项目来进行演示，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/eddycjy/module-repo </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HOME</span>/eddycjy/module-repo</span></span><br></pre></td></tr></table></figure>

<p>然后进行 Go modules 的初始化，如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go mod init github.com/eddycjy/module-repo</span></span><br><span class="line">go: creating new go.mod: module github.com/eddycjy/module-repo</span><br></pre></td></tr></table></figure>

<p>在执行 <code>go mod init</code> 命令时，我们指定了模块导入路径为 <code>github.com/eddycjy/module-repo</code>。接下来我们在该项目根目录下创建 main.go 文件，如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/eddycjy/mquote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(mquote.GetHello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在项目根目录执行 <code>go get github.com/eddycjy/mquote</code> 命令，如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/eddycjy/mquote </span></span><br><span class="line">go: finding github.com/eddycjy/mquote latest</span><br><span class="line">go: downloading github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f</span><br><span class="line">go: extracting github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f</span><br></pre></td></tr></table></figure>

<h4 id="查看-go-mod-文件"><a href="#查看-go-mod-文件" class="headerlink" title="查看 go.mod 文件"></a>查看 go.mod 文件</h4><p>在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识，同时也是 GO111MODULE 值为 auto 时的识别标识，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头。</p>
<p>在我们刚刚进行了初始化和简单拉取后，我们再次查看 go.mod 文件，基本内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com&#x2F;eddycjy&#x2F;module-repo</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com&#x2F;eddycjy&#x2F;mquote v0.0.0-20200220041913-e066a990ce6f</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>为了更进一步的讲解，我们模拟引用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module github.com&#x2F;eddycjy&#x2F;module-repo</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    example.com&#x2F;apple v0.1.2</span><br><span class="line">    example.com&#x2F;banana v1.2.3</span><br><span class="line">    example.com&#x2F;banana&#x2F;v2 v2.3.4</span><br><span class="line">    example.com&#x2F;pear &#x2F;&#x2F; indirect</span><br><span class="line">    example.com&#x2F;strawberry &#x2F;&#x2F; incompatible</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">exclude example.com&#x2F;banana v1.2.4</span><br><span class="line">replace example.com&#x2F;apple v0.1.2 &#x3D;&gt; example.com&#x2F;fried v0.1.0 </span><br><span class="line">replace example.com&#x2F;banana &#x3D;&gt; example.com&#x2F;fish</span><br></pre></td></tr></table></figure>

<ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。</li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本</li>
</ul>
<p>另外你会发现 <code>example.com/pear</code> 的后面会有一个 indirect 标识，indirect 标识表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 <code>go get</code> 拉取下来的，也有可能是你所依赖的模块所依赖的，情况有好几种。</p>
<h4 id="查看go-sum文件"><a href="#查看go-sum文件" class="headerlink" title="查看go.sum文件"></a>查看go.sum文件</h4><p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">github.com&#x2F;eddycjy&#x2F;mquote v0.0.1 h1:4QHXKo7J8a6J&#x2F;k8UA6CiHhswJQs0sm2foAQQUq8GFHM&#x3D;</span><br><span class="line">github.com&#x2F;eddycjy&#x2F;mquote v0.0.1&#x2F;go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&#x3D;</span><br><span class="line">github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module&#x2F;tour v0.0.1 h1:cc+pgV0LnR8Fhou0zNHughT7IbSnLvfUZ+X3fvshrv8&#x3D;</span><br><span class="line">github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module&#x2F;tour v0.0.1&#x2F;go.mod h1:8uL1FOiQJZ4&#x2F;1hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I&#x3D;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到一个模块路径可能有如下两种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com&#x2F;eddycjy&#x2F;mquote v0.0.1 h1:4QHXKo7J8a6J&#x2F;k8UA6CiHhswJQs0sm2foAQQUq8GFHM&#x3D;github.com&#x2F;eddycjy&#x2F;mquote v0.0.1&#x2F;go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg&#x3D;</span><br></pre></td></tr></table></figure>

<p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p>
<p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p>
<h4 id="查看全局缓存"><a href="#查看全局缓存" class="headerlink" title="查看全局缓存"></a>查看全局缓存</h4><p>我们刚刚成功的将 <code>github.com/eddycjy/mquote</code> 模块拉取了下来，其拉取的结果缓存在  <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sumdb</code> 目录下，而在<code>mod</code>目录下会以 <code>github.com/foo/bar</code> 的格式进行存放，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mod</span><br><span class="line">├── cache</span><br><span class="line">├── github.com</span><br><span class="line">├── golang.org</span><br><span class="line">├── google.golang.org</span><br><span class="line">├── gopkg.in</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>需要注意的是同一个模块版本的数据只缓存一份，所有其它模块共享使用。如果你希望清理所有已缓存的模块版本数据，可以执行 <code>go clean -modcache</code> 命令。</p>
<h2 id="Go-Modules-下的-go-get-行为"><a href="#Go-Modules-下的-go-get-行为" class="headerlink" title="Go Modules 下的 go get 行为"></a>Go Modules 下的 go get 行为</h2><p>在拉取项目依赖时，你会发现拉取的过程总共分为了三大步，分别是 finding（发现）、downloading（下载）以及 extracting（提取）， 并且在拉取信息上一共分为了三段内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       所拉取版本commit时间</span><br><span class="line">v0.0.0-20200413041913-e066a990ce6f</span><br><span class="line">版本信息                所拉取版本commit哈希</span><br></pre></td></tr></table></figure>



<p>需要注意的是，所拉取版本的 commit 时间是以UTC时区为准，而并非本地时区，同时我们会发现我们 <code>go get</code> 命令所拉取到的版本是 v0.0.0，这是因为我们是直接执行 <code>go get -u</code> 获取的，并没有指定任何的版本信息，由 Go modules 自行按照内部规则进行选择。</p>
<h3 id="go-get-的拉取行为"><a href="#go-get-的拉取行为" class="headerlink" title="go get 的拉取行为"></a>go get 的拉取行为</h3><p>刚刚我们用 <code>go get</code> 命令拉取了新的依赖，那么 <code>go get</code> 又提供了哪些功能呢，常用的拉取命令如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">go get</td>
<td align="left">拉取依赖，会进行指定性拉取（更新），并不会更新所依赖的其它模块。</td>
</tr>
<tr>
<td align="left">go get -u</td>
<td align="left">更新现有的依赖，会强制更新它所依赖的其它全部模块，不包括自身。</td>
</tr>
<tr>
<td align="left">go get -u -t ./…</td>
<td align="left">更新所有直接依赖和间接依赖的模块版本，包括单元测试中用到的。</td>
</tr>
</tbody></table>
<p>那么我想选择具体版本应当如何执行呢，如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">go get golang.org/x/text@latest</td>
<td align="left">拉取最新的版本，若存在tag，则优先使用。</td>
</tr>
<tr>
<td align="left">go get golang.org/x/text@master</td>
<td align="left">拉取 master 分支的最新 commit。</td>
</tr>
<tr>
<td align="left">go get golang.org/x/text@v0.3.2</td>
<td align="left">拉取 tag 为 v0.3.2 的 commit。</td>
</tr>
<tr>
<td align="left">go get golang.org/x/text@342b2e</td>
<td align="left">拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2。</td>
</tr>
</tbody></table>
<h3 id="go-get-的版本选择"><a href="#go-get-的版本选择" class="headerlink" title="go get 的版本选择"></a>go get 的版本选择</h3><p>我们回顾一下我们拉取的 <code>go get github.com/eddycjy/mquote</code>，其结果是 <code>v0.0.0-20200220041913-e066a990ce6f</code>，对照着上面所提到的 <code>go get</code> 行为来看，你可能还会有一些疑惑，那就是在 <code>go get</code> 没有指定任何版本的情况下，它的版本选择规则是怎么样的，也就是为什么<code>go get</code> 拉取的是 <code>v0.0.0</code>，它什么时候会拉取正常带版本号的 tags 呢。实际上这需要区分两种情况，如下：</p>
<ol>
<li><p>所拉取的模块有发布 tags：</p>
</li>
<li><ul>
<li>如果只有单个模块，那么就取主版本号最大的那个tag。</li>
<li>如果有多个模块，则推算相应的模块路径，取主版本号最大的那个tag（子模块的tag的模块路径会有前缀要求）</li>
</ul>
</li>
<li><p>所拉取的模块没有发布过 tags：</p>
</li>
<li><ul>
<li>默认取主分支最新一次 commit 的 commithash。</li>
</ul>
</li>
</ol>
<h4 id="没有发布过-tags"><a href="#没有发布过-tags" class="headerlink" title="没有发布过 tags"></a>没有发布过 tags</h4><p>那么为什么会拉取的是 <code>v0.0.0</code> 呢，是因为 <code>github.com/eddycjy/mquote</code> 没有发布任何的tag。</p>
<p>因此它默认取的是主分支最新一次 commit 的 commit 时间和 commithash，也就是 <code>20200220041913-e066a990ce6f</code>，属于第二种情况。</p>
<h4 id="有发布-tags"><a href="#有发布-tags" class="headerlink" title="有发布 tags"></a>有发布 tags</h4><p>在项目有发布 tags 的情况下，还存在着多种模式，也就是只有单个模块和多个模块，我们统一以多个模块来进行展示，因为多个模块的情况下就已经包含了单个模块的使用了。如下图：</p>
<p><img src="/images/golang-no1.png" alt="image"></p>
<p>在这个项目中，我们一共打了两个tag，分别是：v0.0.1 和 module/tour/v0.0.1。这时候你可能会奇怪，为什么要打 <code>module/tour/v0.0.1</code> 这么“奇怪”的tag，这有什么用意吗？</p>
<p>其实是 Go modules 在同一个项目下多个模块的tag表现方式，其主要目录结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mquote</span><br><span class="line">├── go.mod</span><br><span class="line">├── module</span><br><span class="line">│   └── tour</span><br><span class="line">│       ├── go.mod</span><br><span class="line">│       └── tour.go</span><br><span class="line">└── quote.go</span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>mquote</code> 这个项目的根目录有一个 go.mod 文件，而在 <code>module/tour</code> 目录下也有一个 go.mod 文件，其模块导入和版本信息的对应关系如下:</p>
<table>
<thead>
<tr>
<th align="left">tag</th>
<th align="left">模块导入路径</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v0.0.1</td>
<td align="left">github.com/eddycjy/mquote</td>
<td align="left">mquote 项目的v 0.0.1 版本</td>
</tr>
<tr>
<td align="left">module/tour/v0.01</td>
<td align="left">github.com/eddycjy/mquote/module/tour</td>
<td align="left">mquote 项目下的子模块 module/tour 的 v0.0.1 版本</td>
</tr>
</tbody></table>
<h4 id="导入主模块和子模块"><a href="#导入主模块和子模块" class="headerlink" title="导入主模块和子模块"></a>导入主模块和子模块</h4><p>结合上述内容，拉取主模块的话，还是照旧执行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com&#x2F;eddycjy&#x2F;mquote@v0.0.1</span><br><span class="line">go: finding github.com&#x2F;eddycjy&#x2F;mquote v0.0.1</span><br><span class="line">go: downloading github.com&#x2F;eddycjy&#x2F;mquote v0.0.1</span><br><span class="line">go: extracting github.com&#x2F;eddycjy&#x2F;mquote v0.0.1</span><br></pre></td></tr></table></figure>

<p>如果是想拉取子模块，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module&#x2F;tour@v0.0.1</span><br><span class="line">go: finding github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module v0.0.1</span><br><span class="line">go: finding github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module&#x2F;tour v0.0.1</span><br><span class="line">go: downloading github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module&#x2F;tour v0.0.1</span><br><span class="line">go: extracting github.com&#x2F;eddycjy&#x2F;mquote&#x2F;module&#x2F;tour v0.0.1</span><br></pre></td></tr></table></figure>

<p>我们将主模块和子模块的拉取进行对比，你会发现子模块的拉取会多出一步，它会先发现 <code>github.com/eddycjy/mquote/module</code>，再继续推算，最终拉取到 <code>module/tour</code>。</p>
<h2 id="Go-Modules-的导入路径说明"><a href="#Go-Modules-的导入路径说明" class="headerlink" title="Go Modules 的导入路径说明"></a>Go Modules 的导入路径说明</h2><h3 id="不同版本的导入路径"><a href="#不同版本的导入路径" class="headerlink" title="不同版本的导入路径"></a>不同版本的导入路径</h3><p>在前面的模块拉取和引用中，你会发现我们的模块导入路径就是 <code>github.com/eddycjy/mquote</code>和  <code>github.com/eddycjy/mquote/module/tour</code>，似乎并没有什么特殊的。</p>
<p>其实不然，实际上 Go modules 在主版本号为 v0 和 v1 的情况下省略了版本号，而在主版本号为v2及以上则需要明确指定出主版本号，否则会出现冲突，其tag与模块导入路径的大致对应关系如下：</p>
<table>
<thead>
<tr>
<th align="left">tag</th>
<th align="left">模块导入路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v0.0.0</td>
<td align="left">github.com/eddycjy/mquote</td>
</tr>
<tr>
<td align="left">v1.0.0</td>
<td align="left">github.com/eddycjy/mquote</td>
</tr>
<tr>
<td align="left">v2.0.0</td>
<td align="left">github.com/eddycjy/mquote/v2</td>
</tr>
<tr>
<td align="left">v3.0.0</td>
<td align="left">github.com/eddycjy/mquote/v3</td>
</tr>
</tbody></table>
<p>简单来讲，就是主版本号为 v0 和 v1 时，不需要在模块导入路径包含主版本的信息，而在 v1 版本以后，也就是 v2 起，必须要在模块的导入路径末尾加上主版本号，引用时就需要调整为如下格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/eddycjy/mquote/v2/example"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>另外忽略主版本号 v0 和 v1 是强制性的（不是可选项），因此每个软件包只有一个明确且规范的导入路径。</p>
<h3 id="为什么忽略-v0-和-v1-的主版本号"><a href="#为什么忽略-v0-和-v1-的主版本号" class="headerlink" title="为什么忽略 v0 和 v1 的主版本号"></a>为什么忽略 v0 和 v1 的主版本号</h3><p>导入路径中忽略 v1 版本的原因是：考虑到许多开发人员创建一旦到达 v1 版本便永不改变的软件包，这是官方所鼓励的，不认为所有这些开发人员在无意发布 v2 版时都应被迫拥有明确的 v1 版本尾缀，这将导致 v1 版本变成“噪音”且无意义。</p>
<p>导入路径中忽略了 v0 版本的原因是：根据语义化版本规范，v0的这些版本完全没有兼容性保证。需要一个显式的 v0 版本的标识对确保兼容性没有多大帮助。</p>
<h2 id="Go-Modules-的语义化版本控制"><a href="#Go-Modules-的语义化版本控制" class="headerlink" title="Go Modules 的语义化版本控制"></a>Go Modules 的语义化版本控制</h2><p>我们不断地在 Go Modules 的使用中提到版本号，其实质上被称为“语义化版本”，假设我们的版本号是 v1.2.3，如下：</p>
<p><img src="/images/golang-no2.png" alt="image"></p>
<p>其版本格式为 “主版本号.次版本号.修订号”，版本号的递增规则如下：</p>
<ol>
<li>主版本号：当你做了不兼容的 API 修改。</li>
<li>次版本号：当你做了向下兼容的功能性新增。</li>
<li>修订号：当你做了向下兼容的问题修正</li>
</ol>
<p>假设你是先行版本号或特殊情况，可以将版本信息追加到“主版本号.次版本号.修订号”的后面，作为延伸，如下：</p>
<p><img src="/images/golang-no3.png" alt="image"></p>
<p>至此我们介绍了 Go modules 所支持的两类版本号方式，在我们发布新版本打 tag 的时候，需要注意遵循，否则不遵循语义化版本规则的版本号都是无法进行拉取的。</p>
<h2 id="Go-Modules-的最小版本选择"><a href="#Go-Modules-的最小版本选择" class="headerlink" title="Go Modules 的最小版本选择"></a>Go Modules 的最小版本选择</h2><p>现在我们已经有一个模块，也有发布的 tag，但是一个模块往往依赖着许多其它许许多多的模块，并且不同的模块在依赖时很有可能会出现依赖同一个模块的不同版本，如下图（来自 Russ Cox）：</p>
<p><img src="/images/golang-no4.png" alt="image"></p>
<p>在上述依赖中，模块 A 依赖了模块 B 和模块 C，而模块 B 依赖了模块 D，模块 C 依赖了模块 D 和 F，模块 D 又依赖了模块 E，而且同模块的不同版本还依赖了对应模块的不同版本。那么这个时候 Go modules 怎么选择版本，选择的是哪一个版本呢？</p>
<p>我们根据 proposal 可得知，Go modules 会把每个模块的依赖版本清单都整理出来，最终得到一个构建清单，如下图（来自 Russ Cox）：</p>
<p><img src="/images/golang-no5.png" alt="image"></p>
<p>我们看到 rough list 和 final list，两者的区别在于重复引用的模块 D（v1.3、v1.4），其最终清单选用了模块 D 的 v1.4 版本，主要原因：</p>
<ol>
<li>语义化版本的控制：因为模块 D 的 v1.3 和 v1.4 版本变更，都属于次版本号的变更，而在语义化版本的约束下，v1.4 必须是要向下兼容 v1.3 版本，因此认为不存在破坏性变更，也就是兼容的。</li>
<li>模块导入路径的规范：主版本号不同，模块的导入路径不一样，因此若出现不兼容的情况，其主版本号会改变，模块的导入路径自然也就改变了，因此不会与第一点的基础相冲突。</li>
</ol>
<h2 id="go-sum-文件要不要提交"><a href="#go-sum-文件要不要提交" class="headerlink" title="go.sum 文件要不要提交"></a>go.sum 文件要不要提交</h2><p>理论上 go.mod 和 go.sum 文件都应该提交到你的 Git 仓库中去。</p>
<p>假设我们不上传 go.sum 文件，就会造成每个人执行 Go modules 相关命令，又会生成新的一份 go.sum，也就是会重新到上游拉取，再拉取时有可能就是被篡改过的了，会有很大的安全隐患，失去了与基准版本（第一个所提交的人，所期望的版本）的校验内容，因此 go.sum文件是需要提交。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此我们介绍了 Go modules 的前世今生、基本使用和在 Go modules 模式下 <code>go get</code> 命令的行为转换，同时我们对常见的多版本导入路径、语义化版本控制以及多模块的最小版本选择规则进行了大致的介绍。</p>
<p>Go modules 的成长和发展经历了一定的过程，如果你是刚接触的读者，直接基于 Go modules 的项目开始即可，如果既有老项目，那么是时候考虑切换过来了，Go1.14起已经准备就绪，并推荐你使用。</p>
<p>此文转载至我要煎鱼说，作者陈煎鱼—原文地址：<a href="https://mp.weixin.qq.com/s/fNMXfpBhBC3UWTbYCnwIMg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fNMXfpBhBC3UWTbYCnwIMg</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    ihere
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ihere.io/2020/04/13/go-mod-%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/" title="go mod 基础设置">https://ihere.io/2020/04/13/go-mod-%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow" target="_blank">CC BY-NC 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Golang-mod/" rel="tag"># Golang, mod</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/30/Kubernetes-Q-A/" rel="next" title="Kubernetes Q&A">
                <i class="fa fa-chevron-left"></i> Kubernetes Q&A
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/19/OpenVPN-admin/" rel="prev" title="OpenVPN admin">
                OpenVPN admin <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ihere</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Go-Modules"><span class="nav-number">1.</span> <span class="nav-text">什么是Go Modules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GOPATH-是什么"><span class="nav-number">2.</span> <span class="nav-text">GOPATH 是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#弃用GOPATH"><span class="nav-number">2.1.</span> <span class="nav-text">弃用GOPATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#govendor"><span class="nav-number">2.2.</span> <span class="nav-text">govendor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-Modules的产生"><span class="nav-number">3.</span> <span class="nav-text">Go Modules的产生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-Modules的使用"><span class="nav-number">3.1.</span> <span class="nav-text">Go Modules的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GO111MODULE"><span class="nav-number">3.1.1.</span> <span class="nav-text">GO111MODULE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GOPROXY"><span class="nav-number">3.1.2.</span> <span class="nav-text">GOPROXY</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#direct是什么"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">direct是什么</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GOSUMDB"><span class="nav-number">3.1.3.</span> <span class="nav-text">GOSUMDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GONOPROXY-GONOSUMDB-GOPRIVATE"><span class="nav-number">3.1.4.</span> <span class="nav-text">GONOPROXY&#x2F;GONOSUMDB&#x2F;GOPRIVATE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开启-Go-Modules"><span class="nav-number">3.2.</span> <span class="nav-text">开启 Go Modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用go-modules初始化项目"><span class="nav-number">3.3.</span> <span class="nav-text">使用go modules初始化项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看-go-mod-文件"><span class="nav-number">3.3.1.</span> <span class="nav-text">查看 go.mod 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看go-sum文件"><span class="nav-number">3.3.2.</span> <span class="nav-text">查看go.sum文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看全局缓存"><span class="nav-number">3.3.3.</span> <span class="nav-text">查看全局缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-Modules-下的-go-get-行为"><span class="nav-number">4.</span> <span class="nav-text">Go Modules 下的 go get 行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-get-的拉取行为"><span class="nav-number">4.1.</span> <span class="nav-text">go get 的拉取行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-get-的版本选择"><span class="nav-number">4.2.</span> <span class="nav-text">go get 的版本选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#没有发布过-tags"><span class="nav-number">4.2.1.</span> <span class="nav-text">没有发布过 tags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有发布-tags"><span class="nav-number">4.2.2.</span> <span class="nav-text">有发布 tags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导入主模块和子模块"><span class="nav-number">4.2.3.</span> <span class="nav-text">导入主模块和子模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-Modules-的导入路径说明"><span class="nav-number">5.</span> <span class="nav-text">Go Modules 的导入路径说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同版本的导入路径"><span class="nav-number">5.1.</span> <span class="nav-text">不同版本的导入路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么忽略-v0-和-v1-的主版本号"><span class="nav-number">5.2.</span> <span class="nav-text">为什么忽略 v0 和 v1 的主版本号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-Modules-的语义化版本控制"><span class="nav-number">6.</span> <span class="nav-text">Go Modules 的语义化版本控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-Modules-的最小版本选择"><span class="nav-number">7.</span> <span class="nav-text">Go Modules 的最小版本选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-sum-文件要不要提交"><span class="nav-number">8.</span> <span class="nav-text">go.sum 文件要不要提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ihere</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
